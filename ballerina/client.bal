// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://app.asana.com/api/1.0") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get an attachment
    #
    # + attachmentGid - Globally unique identifier for the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a single attachment 
    resource isolated function get attachments/[string attachmentGid](map<string|string[]> headers = {}, *GetAttachmentQueries queries) returns AttachmentOkResponse|error {
        string resourcePath = string `/attachments/${getEncodedUri(attachmentGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete an attachment
    #
    # + attachmentGid - Globally unique identifier for the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified attachment 
    resource isolated function delete attachments/[string attachmentGid](map<string|string[]> headers = {}, *DeleteAttachmentQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/attachments/${getEncodedUri(attachmentGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get attachments from an object
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified object's attachments 
    resource isolated function get attachments(map<string|string[]> headers = {}, *GetAttachmentsForObjectQueries queries) returns AttachmentCompacts|error {
        string resourcePath = string `/attachments`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Upload an attachment
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The file you want to upload 
    # + return - Successfully uploaded the attachment to the parent object 
    resource isolated function post attachments(AttachmentRequest payload, map<string|string[]> headers = {}, *CreateAttachmentForObjectQueries queries) returns AttachmentOkResponse|error {
        string resourcePath = string `/attachments`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get audit log events
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - AuditLogEvents were successfully retrieved 
    resource isolated function get workspaces/[string workspaceGid]/audit_log_events(map<string|string[]> headers = {}, *GetAuditLogEventsQueries queries) returns AuditLogEventResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/audit_log_events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Submit parallel requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The requests to batch together via the Batch API 
    # + return - Successfully completed the requested batch API operations 
    resource isolated function post batch(BatchBody payload, map<string|string[]> headers = {}, *CreateBatchRequestQueries queries) returns BatchesResponse|error {
        string resourcePath = string `/batch`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a project's custom fields
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved custom field settings objects for a project 
    resource isolated function get projects/[string projectGid]/custom_field_settings(map<string|string[]> headers = {}, *GetCustomFieldSettingsForProjectQueries queries) returns CustomFieldSettingsResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/custom_field_settings`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a portfolio's custom fields
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved custom field settings objects for a portfolio 
    resource isolated function get portfolios/[string portfolioGid]/custom_field_settings(map<string|string[]> headers = {}, *GetCustomFieldSettingsForPortfolioQueries queries) returns CustomFieldSettingsResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/custom_field_settings`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a custom field
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The custom field object to create 
    # + return - Custom field successfully created 
    resource isolated function post custom_fields(CustomFieldsBody payload, map<string|string[]> headers = {}, *CreateCustomFieldQueries queries) returns CustomFieldCreatedResponse|error {
        string resourcePath = string `/custom_fields`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a custom field
    #
    # + customFieldGid - Globally unique identifier for the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the complete definition of a custom fieldâ€™s metadata 
    resource isolated function get custom_fields/[string customFieldGid](map<string|string[]> headers = {}, *GetCustomFieldQueries queries) returns CustomFieldCreatedResponse|error {
        string resourcePath = string `/custom_fields/${getEncodedUri(customFieldGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a custom field
    #
    # + customFieldGid - Globally unique identifier for the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The custom field object with all updated properties 
    # + return - The custom field was successfully updated 
    resource isolated function put custom_fields/[string customFieldGid](CustomFieldscustomFieldGidBody payload, map<string|string[]> headers = {}, *UpdateCustomFieldQueries queries) returns CustomFieldCreatedResponse|error {
        string resourcePath = string `/custom_fields/${getEncodedUri(customFieldGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a custom field
    #
    # + customFieldGid - Globally unique identifier for the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The custom field was successfully deleted 
    resource isolated function delete custom_fields/[string customFieldGid](map<string|string[]> headers = {}, *DeleteCustomFieldQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/custom_fields/${getEncodedUri(customFieldGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a workspace's custom fields
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved all custom fields for the given workspace 
    resource isolated function get workspaces/[string workspaceGid]/custom_fields(map<string|string[]> headers = {}, *GetCustomFieldsForWorkspaceQueries queries) returns CustomFieldsResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/custom_fields`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create an enum option
    #
    # + customFieldGid - Globally unique identifier for the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The enum option object to create 
    # + return - Custom field enum option successfully created 
    resource isolated function post custom_fields/[string customFieldGid]/enum_options(CustomFieldGidEnumOptionsBody payload, map<string|string[]> headers = {}, *CreateEnumOptionForCustomFieldQueries queries) returns EnumOptions|error {
        string resourcePath = string `/custom_fields/${getEncodedUri(customFieldGid)}/enum_options`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reorder a custom field's enum
    #
    # + customFieldGid - Globally unique identifier for the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The enum option object to create 
    # + return - Custom field enum option successfully reordered 
    resource isolated function post custom_fields/[string customFieldGid]/enum_options/insert(EnumOptionsInsertBody payload, map<string|string[]> headers = {}, *InsertEnumOptionForCustomFieldQueries queries) returns EnumOptions|error {
        string resourcePath = string `/custom_fields/${getEncodedUri(customFieldGid)}/enum_options/insert`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update an enum option
    #
    # + enumOptionGid - Globally unique identifier for the enum option
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The enum option object to update 
    # + return - Successfully updated the specified custom field enum 
    resource isolated function put enum_options/[string enumOptionGid](EnumOptionsenumOptionGidBody payload, map<string|string[]> headers = {}, *UpdateEnumOptionQueries queries) returns EnumOptions|error {
        string resourcePath = string `/enum_options/${getEncodedUri(enumOptionGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get events on a resource
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved events 
    resource isolated function get events(map<string|string[]> headers = {}, *GetEventsQueries queries) returns EventsResponse|error {
        string resourcePath = string `/events`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a goal relationship
    #
    # + goalRelationshipGid - Globally unique identifier for the goal relationship
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for the goal relationship 
    resource isolated function get goal_relationships/[string goalRelationshipGid](map<string|string[]> headers = {}, *GetGoalRelationshipQueries queries) returns GoalRelationshipOkResponse|error {
        string resourcePath = string `/goal_relationships/${getEncodedUri(goalRelationshipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a goal relationship
    #
    # + goalRelationshipGid - Globally unique identifier for the goal relationship
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the goal relationship 
    # + return - Successfully updated the goal relationship 
    resource isolated function put goal_relationships/[string goalRelationshipGid](GoalRelationshipsgoalRelationshipGidBody payload, map<string|string[]> headers = {}, *UpdateGoalRelationshipQueries queries) returns GoalRelationshipOkResponse|error {
        string resourcePath = string `/goal_relationships/${getEncodedUri(goalRelationshipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get goal relationships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested goal relationships 
    resource isolated function get goal_relationships(map<string|string[]> headers = {}, *GetGoalRelationshipsQueries queries) returns GoalRelationshipCompacts|error {
        string resourcePath = string `/goal_relationships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add a supporting goal relationship
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The supporting resource to be added to the goal 
    # + return - Successfully created the goal relationship 
    resource isolated function post goals/[string goalGid]/addSupportingRelationship(GoalGidAddSupportingRelationshipBody payload, map<string|string[]> headers = {}, *AddSupportingRelationshipQueries queries) returns GoalRelationshipOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/addSupportingRelationship`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Removes a supporting goal relationship
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The supporting resource to be removed from the goal 
    # + return - Successfully removed the goal relationship 
    resource isolated function post goals/[string goalGid]/removeSupportingRelationship(GoalGidRemoveSupportingRelationshipBody payload, map<string|string[]> headers = {}, *RemoveSupportingRelationshipQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/removeSupportingRelationship`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a single goal 
    resource isolated function get goals/[string goalGid](map<string|string[]> headers = {}, *GetGoalQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the goal 
    # + return - Successfully updated the goal 
    resource isolated function put goals/[string goalGid](GoalsgoalGidBody payload, map<string|string[]> headers = {}, *UpdateGoalQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified goal 
    resource isolated function delete goals/[string goalGid](map<string|string[]> headers = {}, *DeleteGoalQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get goals
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested goals 
    resource isolated function get goals(map<string|string[]> headers = {}, *GetGoalsQueries queries) returns GoalCompactsResponse|error {
        string resourcePath = string `/goals`;
        map<Encoding> queryParamEncoding = {"time_periods": {style: FORM, explode: true}, "opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a goal
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The goal to create 
    # + return - Successfully created a new goal 
    resource isolated function post goals(GoalsBody payload, map<string|string[]> headers = {}, *CreateGoalQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create a goal metric
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The goal metric to create 
    # + return - Successfully created a new goal metric 
    resource isolated function post goals/[string goalGid]/setMetric(GoalGidSetMetricBody payload, map<string|string[]> headers = {}, *CreateGoalMetricQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/setMetric`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update a goal metric
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the goal metric 
    # + return - Successfully updated the goal metric 
    resource isolated function post goals/[string goalGid]/setMetricCurrentValue(GoalGidSetMetricCurrentValueBody payload, map<string|string[]> headers = {}, *UpdateGoalMetricQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/setMetricCurrentValue`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add a collaborator to a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The followers to be added as collaborators 
    # + return - Successfully added users as collaborators 
    resource isolated function post goals/[string goalGid]/addFollowers(GoalGidAddFollowersBody payload, map<string|string[]> headers = {}, *AddFollowersQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/addFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a collaborator from a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The followers to be removed as collaborators 
    # + return - Successfully removed users as collaborators 
    resource isolated function post goals/[string goalGid]/removeFollowers(GoalGidRemoveFollowersBody payload, map<string|string[]> headers = {}, *RemoveFollowersQueries queries) returns GoalOkResponse|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/removeFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get parent goals from a goal
    #
    # + goalGid - Globally unique identifier for the goal
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified goal's parent goals 
    resource isolated function get goals/[string goalGid]/parentGoals(map<string|string[]> headers = {}, *GetParentGoalsForGoalQueries queries) returns GoalCompacts|error {
        string resourcePath = string `/goals/${getEncodedUri(goalGid)}/parentGoals`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a job by id
    #
    # + jobGid - Globally unique identifier for the job
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved Job 
    resource isolated function get jobs/[string jobGid](map<string|string[]> headers = {}, *GetJobQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/jobs/${getEncodedUri(jobGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple memberships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested membership 
    resource isolated function get memberships(map<string|string[]> headers = {}, *GetMembershipsQueries queries) returns MembershipCompacts|error {
        string resourcePath = string `/memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a membership
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the membership 
    # + return - Successfully created the requested membership 
    resource isolated function post memberships(MembershipsBody payload, map<string|string[]> headers = {}, *CreateMembershipQueries queries) returns MembershipCreatedResponse|error {
        string resourcePath = string `/memberships`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a membership
    #
    # + membershipGid - Globally unique identifier for the membership
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a single membership 
    resource isolated function get memberships/[string membershipGid](map<string|string[]> headers = {}, *GetMembershipQueries queries) returns ProjectMembershipCompactOkResponse|error {
        string resourcePath = string `/memberships/${getEncodedUri(membershipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a membership
    #
    # + membershipGid - Globally unique identifier for the membership
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The membership to update 
    # + return - Successfully updated the requested membership 
    resource isolated function put memberships/[string membershipGid](MembershipsmembershipGidBody payload, map<string|string[]> headers = {}, *UpdateMembershipQueries queries) returns MembershipCreatedResponse|error {
        string resourcePath = string `/memberships/${getEncodedUri(membershipGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a membership
    #
    # + membershipGid - Globally unique identifier for the membership
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the requested membership 
    resource isolated function delete memberships/[string membershipGid](map<string|string[]> headers = {}, *DeleteMembershipQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/memberships/${getEncodedUri(membershipGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create an organization export request
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The organization to export 
    # + return - Successfully created organization export request 
    resource isolated function post organization_exports(OrganizationExportsBody payload, map<string|string[]> headers = {}, *CreateOrganizationExportQueries queries) returns OrganizationExportCreatedResponse|error {
        string resourcePath = string `/organization_exports`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get details on an org export request
    #
    # + organizationExportGid - Globally unique identifier for the organization export
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved organization export object 
    resource isolated function get organization_exports/[string organizationExportGid](map<string|string[]> headers = {}, *GetOrganizationExportQueries queries) returns OrganizationExportCreatedResponse|error {
        string resourcePath = string `/organization_exports/${getEncodedUri(organizationExportGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple portfolio memberships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved portfolio memberships 
    resource isolated function get portfolio_memberships(map<string|string[]> headers = {}, *GetPortfolioMembershipsQueries queries) returns PortfolioMembershipCompacts|error {
        string resourcePath = string `/portfolio_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a portfolio membership
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested portfolio membership 
    resource isolated function get portfolio_memberships/[string portfolioMembershipGid](map<string|string[]> headers = {}, *GetPortfolioMembershipQueries queries) returns PortfolioMembershipOkResponse|error {
        string resourcePath = string `/portfolio_memberships/${getEncodedUri(portfolioMembershipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get memberships from a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested portfolio's memberships 
    resource isolated function get portfolios/[string portfolioGid]/portfolio_memberships(map<string|string[]> headers = {}, *GetPortfolioMembershipsForPortfolioQueries queries) returns PortfolioMembershipCompacts|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/portfolio_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple portfolios
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved portfolios 
    resource isolated function get portfolios(map<string|string[]> headers = {}, *GetPortfoliosQueries queries) returns PortfolioCompacts|error {
        string resourcePath = string `/portfolios`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a portfolio
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The portfolio to create 
    # + return - Successfully created portfolio 
    resource isolated function post portfolios(PortfoliosBody payload, map<string|string[]> headers = {}, *CreatePortfolioQueries queries) returns PortfolioCreatedResponse|error {
        string resourcePath = string `/portfolios`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested portfolio 
    resource isolated function get portfolios/[string portfolioGid](map<string|string[]> headers = {}, *GetPortfolioQueries queries) returns PortfolioCreatedResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the portfolio 
    # + return - Successfully updated the portfolio 
    resource isolated function put portfolios/[string portfolioGid](PortfoliosportfolioGidBody payload, map<string|string[]> headers = {}, *UpdatePortfolioQueries queries) returns PortfolioCreatedResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified portfolio 
    resource isolated function delete portfolios/[string portfolioGid](map<string|string[]> headers = {}, *DeletePortfolioQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get portfolio items
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested portfolio's items 
    resource isolated function get portfolios/[string portfolioGid]/items(map<string|string[]> headers = {}, *GetItemsForPortfolioQueries queries) returns ProjectCompacts|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/items`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add a portfolio item
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the item being inserted 
    # + return - Successfully added the item to the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/addItem(PortfolioGidAddItemBody payload, map<string|string[]> headers = {}, *AddItemForPortfolioQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/addItem`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a portfolio item
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the item being removed 
    # + return - Successfully removed the item from the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/removeItem(PortfolioGidRemoveItemBody payload, map<string|string[]> headers = {}, *RemoveItemForPortfolioQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/removeItem`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add a custom field to a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the custom field setting 
    # + return - Successfully added the custom field to the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/addCustomFieldSetting(PortfolioGidAddCustomFieldSettingBody payload, map<string|string[]> headers = {}, *AddCustomFieldSettingForPortfolioQueries queries) returns CustomFieldSettingOkResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/addCustomFieldSetting`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a custom field from a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the custom field setting being removed 
    # + return - Successfully removed the custom field from the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/removeCustomFieldSetting(PortfolioGidRemoveCustomFieldSettingBody payload, map<string|string[]> headers = {}, *RemoveCustomFieldSettingForPortfolioQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/removeCustomFieldSetting`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add users to a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the members being added 
    # + return - Successfully added members to the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/addMembers(PortfolioGidAddMembersBody payload, map<string|string[]> headers = {}, *AddMembersForPortfolioQueries queries) returns PortfolioCreatedResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/addMembers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove users from a portfolio
    #
    # + portfolioGid - Globally unique identifier for the portfolio
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the members being removed 
    # + return - Successfully removed the members from the portfolio 
    resource isolated function post portfolios/[string portfolioGid]/removeMembers(PortfolioGidRemoveMembersBody payload, map<string|string[]> headers = {}, *RemoveMembersForPortfolioQueries queries) returns PortfolioCreatedResponse|error {
        string resourcePath = string `/portfolios/${getEncodedUri(portfolioGid)}/removeMembers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a project brief
    #
    # + projectBriefGid - Globally unique identifier for the project brief
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a project brief 
    resource isolated function get project_briefs/[string projectBriefGid](map<string|string[]> headers = {}, *GetProjectBriefQueries queries) returns ProjectBriefOkResponse|error {
        string resourcePath = string `/project_briefs/${getEncodedUri(projectBriefGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a project brief
    #
    # + projectBriefGid - Globally unique identifier for the project brief
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the project brief 
    # + return - Successfully updated the project brief 
    resource isolated function put project_briefs/[string projectBriefGid](ProjectBriefsprojectBriefGidBody payload, map<string|string[]> headers = {}, *UpdateProjectBriefQueries queries) returns ProjectBriefOkResponse|error {
        string resourcePath = string `/project_briefs/${getEncodedUri(projectBriefGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a project brief
    #
    # + projectBriefGid - Globally unique identifier for the project brief
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified project brief 
    resource isolated function delete project_briefs/[string projectBriefGid](map<string|string[]> headers = {}, *DeleteProjectBriefQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/project_briefs/${getEncodedUri(projectBriefGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create a project brief
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project brief to create 
    # + return - Successfully created a new project brief 
    resource isolated function post projects/[string projectGid]/project_briefs(ProjectGidProjectBriefsBody payload, map<string|string[]> headers = {}, *CreateProjectBriefQueries queries) returns ProjectBriefOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/project_briefs`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a project membership
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project membership 
    resource isolated function get project_memberships/[string projectMembershipGid](map<string|string[]> headers = {}, *GetProjectMembershipQueries queries) returns ProjectMembershipNormalOkResponse|error {
        string resourcePath = string `/project_memberships/${getEncodedUri(projectMembershipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get memberships from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project's memberships 
    resource isolated function get projects/[string projectGid]/project_memberships(map<string|string[]> headers = {}, *GetProjectMembershipsForProjectQueries queries) returns ProjectMembershipCompacts|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/project_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a project status
    #
    # + projectStatusGid - The project status update to get
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified project's status updates 
    resource isolated function get project_statuses/[string projectStatusGid](map<string|string[]> headers = {}, *GetProjectStatusQueries queries) returns ProjectStatusOkResponse|error {
        string resourcePath = string `/project_statuses/${getEncodedUri(projectStatusGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a project status
    #
    # + projectStatusGid - The project status update to get
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified project status 
    resource isolated function delete project_statuses/[string projectStatusGid](map<string|string[]> headers = {}, *DeleteProjectStatusQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/project_statuses/${getEncodedUri(projectStatusGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get statuses from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified project's status updates 
    resource isolated function get projects/[string projectGid]/project_statuses(map<string|string[]> headers = {}, *GetProjectStatusesForProjectQueries queries) returns ProjectStatusCompacts|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/project_statuses`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a project status
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project status to create 
    # + return - Successfully created a new story 
    resource isolated function post projects/[string projectGid]/project_statuses(ProjectGidProjectStatusesBody payload, map<string|string[]> headers = {}, *CreateProjectStatusForProjectQueries queries) returns ProjectStatusOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/project_statuses`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a project template
    #
    # + projectTemplateGid - Globally unique identifier for the project template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project template 
    resource isolated function get project_templates/[string projectTemplateGid](map<string|string[]> headers = {}, *GetProjectTemplateQueries queries) returns ProjectTemplateOkResponse|error {
        string resourcePath = string `/project_templates/${getEncodedUri(projectTemplateGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a project template
    #
    # + projectTemplateGid - Globally unique identifier for the project template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified project template 
    resource isolated function delete project_templates/[string projectTemplateGid](map<string|string[]> headers = {}, *DeleteProjectTemplateQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/project_templates/${getEncodedUri(projectTemplateGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get multiple project templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team's or workspace's project templates 
    resource isolated function get project_templates(map<string|string[]> headers = {}, *GetProjectTemplatesQueries queries) returns ProjectTemplateCompacts|error {
        string resourcePath = string `/project_templates`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a team's project templates
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team's project templates 
    resource isolated function get teams/[string teamGid]/project_templates(map<string|string[]> headers = {}, *GetProjectTemplatesForTeamQueries queries) returns ProjectTemplateCompacts|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/project_templates`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Instantiate a project from a project template
    #
    # + projectTemplateGid - Globally unique identifier for the project template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Describes the inputs used for instantiating a project, such as the resulting project's name, which team it should be created in, and values for date variables 
    # + return - Successfully created the job to handle project instantiation 
    resource isolated function post project_templates/[string projectTemplateGid]/instantiateProject(ProjectTemplateGidInstantiateProjectBody payload, map<string|string[]> headers = {}, *InstantiateProjectQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/project_templates/${getEncodedUri(projectTemplateGid)}/instantiateProject`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get multiple projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved projects 
    resource isolated function get projects(map<string|string[]> headers = {}, *GetProjectsQueries queries) returns ProjectCompacts|error {
        string resourcePath = string `/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a project
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project to create 
    # + return - Successfully retrieved projects 
    resource isolated function post projects(ProjectsBody payload, map<string|string[]> headers = {}, *CreateProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project 
    resource isolated function get projects/[string projectGid](map<string|string[]> headers = {}, *GetProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the project 
    # + return - Successfully updated the project 
    resource isolated function put projects/[string projectGid](ProjectsprojectGidBody payload, map<string|string[]> headers = {}, *UpdateProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified project 
    resource isolated function delete projects/[string projectGid](map<string|string[]> headers = {}, *DeleteProjectQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Duplicate a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Describes the duplicate's name and the elements that will be duplicated 
    # + return - Successfully created the job to handle duplication 
    resource isolated function post projects/[string projectGid]/duplicate(ProjectGidDuplicateBody payload, map<string|string[]> headers = {}, *DuplicateProjectQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/duplicate`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get projects a task is in
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the projects for the given task 
    resource isolated function get tasks/[string taskGid]/projects(map<string|string[]> headers = {}, *GetProjectsForTaskQueries queries) returns ProjectCompacts|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a team's projects
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team's projects 
    resource isolated function get teams/[string teamGid]/projects(map<string|string[]> headers = {}, *GetProjectsForTeamQueries queries) returns ProjectCompacts|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a project in a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new project to create 
    # + return - Successfully created the specified project 
    resource isolated function post teams/[string teamGid]/projects(TeamGidProjectsBody payload, map<string|string[]> headers = {}, *CreateProjectForTeamQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all projects in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested workspace's projects 
    resource isolated function get workspaces/[string workspaceGid]/projects(map<string|string[]> headers = {}, *GetProjectsForWorkspaceQueries queries) returns ProjectCompacts|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a project in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new project to create 
    # + return - Successfully created a new project in the specified workspace 
    resource isolated function post workspaces/[string workspaceGid]/projects(WorkspaceGidProjectsBody payload, map<string|string[]> headers = {}, *CreateProjectForWorkspaceQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/projects`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add a custom field to a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the custom field setting 
    # + return - Successfully added the custom field to the project 
    resource isolated function post projects/[string projectGid]/addCustomFieldSetting(ProjectGidAddCustomFieldSettingBody payload, map<string|string[]> headers = {}, *AddCustomFieldSettingForProjectQueries queries) returns CustomFieldSettingOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/addCustomFieldSetting`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a custom field from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the custom field setting being removed 
    # + return - Successfully removed the custom field from the project 
    resource isolated function post projects/[string projectGid]/removeCustomFieldSetting(ProjectGidRemoveCustomFieldSettingBody payload, map<string|string[]> headers = {}, *RemoveCustomFieldSettingForProjectQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/removeCustomFieldSetting`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get task count of a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project's task counts 
    resource isolated function get projects/[string projectGid]/task_counts(map<string|string[]> headers = {}, *GetTaskCountsForProjectQueries queries) returns TaskCountOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/task_counts`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add users to a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the members being added 
    # + return - Successfully added members to the project 
    resource isolated function post projects/[string projectGid]/addMembers(ProjectGidAddMembersBody payload, map<string|string[]> headers = {}, *AddMembersForProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/addMembers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove users from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the members being removed 
    # + return - Successfully removed the members from the project 
    resource isolated function post projects/[string projectGid]/removeMembers(ProjectGidRemoveMembersBody payload, map<string|string[]> headers = {}, *RemoveMembersForProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/removeMembers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add followers to a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the followers being added 
    # + return - Successfully added followers to the project 
    resource isolated function post projects/[string projectGid]/addFollowers(ProjectGidAddFollowersBody payload, map<string|string[]> headers = {}, *AddFollowersForProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/addFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove followers from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the followers being removed 
    # + return - Successfully removed followers from the project 
    resource isolated function post projects/[string projectGid]/removeFollowers(ProjectGidRemoveFollowersBody payload, map<string|string[]> headers = {}, *RemoveFollowersForProjectQueries queries) returns ProjectCreatedResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/removeFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create a project template from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Describes the inputs used for creating a project template, such as the resulting project template's name, which team it should be created in 
    # + return - Successfully created the job to handle project template creation 
    resource isolated function post projects/[string projectGid]/saveAsTemplate(ProjectGidSaveAsTemplateBody payload, map<string|string[]> headers = {}, *ProjectSaveAsTemplateQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/saveAsTemplate`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Trigger a rule
    #
    # + ruleTriggerGid - The ID of the incoming web request trigger. This value is a path parameter that is automatically generated for the API endpoint
    # + headers - Headers to be sent with the request 
    # + payload - A dictionary of variables accessible from within the rule 
    # + return - Successfully triggered a rule 
    resource isolated function post rule_triggers/[string ruleTriggerGid]/run(RuleTriggerGidRunBody payload, map<string|string[]> headers = {}) returns RuleTriggerOkResponse|error {
        string resourcePath = string `/rule_triggers/${getEncodedUri(ruleTriggerGid)}/run`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a section
    #
    # + sectionGid - The globally unique identifier for the section
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved section 
    resource isolated function get sections/[string sectionGid](map<string|string[]> headers = {}, *GetSectionQueries queries) returns SectionOkResponse|error {
        string resourcePath = string `/sections/${getEncodedUri(sectionGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a section
    #
    # + sectionGid - The globally unique identifier for the section
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The section to create 
    # + return - Successfully updated the specified section 
    resource isolated function put sections/[string sectionGid](SectionssectionGidBody payload, map<string|string[]> headers = {}, *UpdateSectionQueries queries) returns SectionOkResponse|error {
        string resourcePath = string `/sections/${getEncodedUri(sectionGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a section
    #
    # + sectionGid - The globally unique identifier for the section
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified section 
    resource isolated function delete sections/[string sectionGid](map<string|string[]> headers = {}, *DeleteSectionQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/sections/${getEncodedUri(sectionGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get sections in a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved sections in project 
    resource isolated function get projects/[string projectGid]/sections(map<string|string[]> headers = {}, *GetSectionsForProjectQueries queries) returns SectionCompacts|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/sections`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a section in a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The section to create 
    # + return - Successfully created the specified section 
    resource isolated function post projects/[string projectGid]/sections(ProjectGidSectionsBody payload, map<string|string[]> headers = {}, *CreateSectionForProjectQueries queries) returns SectionOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/sections`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add task to section
    #
    # + sectionGid - The globally unique identifier for the section
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The task and optionally the insert location 
    # + return - Successfully added the task 
    resource isolated function post sections/[string sectionGid]/addTask(SectionGidAddTaskBody payload, map<string|string[]> headers = {}, *AddTaskForSectionQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/sections/${getEncodedUri(sectionGid)}/addTask`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Move or Insert sections
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The section's move action 
    # + return - Successfully moved the specified section 
    resource isolated function post projects/[string projectGid]/sections/insert(SectionsInsertBody payload, map<string|string[]> headers = {}, *InsertSectionForProjectQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/sections/insert`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a status update
    #
    # + statusUpdateGid - The status update to get
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified object's status updates 
    resource isolated function get status_updates/[string statusUpdateGid](map<string|string[]> headers = {}, *GetStatusQueries queries) returns StatusUpdateOkResponse|error {
        string resourcePath = string `/status_updates/${getEncodedUri(statusUpdateGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a status update
    #
    # + statusUpdateGid - The status update to get
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified status 
    resource isolated function delete status_updates/[string statusUpdateGid](map<string|string[]> headers = {}, *DeleteStatusQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/status_updates/${getEncodedUri(statusUpdateGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get status updates from an object
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified object's status updates 
    resource isolated function get status_updates(map<string|string[]> headers = {}, *GetStatusesForObjectQueries queries) returns StatusUpdateCompacts|error {
        string resourcePath = string `/status_updates`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a status update
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The status update to create 
    # + return - Successfully created a new status update 
    resource isolated function post status_updates(StatusUpdatesBody payload, map<string|string[]> headers = {}, *CreateStatusForObjectQueries queries) returns StatusUpdateOkResponse|error {
        string resourcePath = string `/status_updates`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a story
    #
    # + storyGid - Globally unique identifier for the story
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified story 
    resource isolated function get stories/[string storyGid](map<string|string[]> headers = {}, *GetStoryQueries queries) returns StoryOkResponse|error {
        string resourcePath = string `/stories/${getEncodedUri(storyGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a story
    #
    # + storyGid - Globally unique identifier for the story
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The comment story to update 
    # + return - Successfully retrieved the specified story 
    resource isolated function put stories/[string storyGid](StoriesstoryGidBody payload, map<string|string[]> headers = {}, *UpdateStoryQueries queries) returns StoryOkResponse|error {
        string resourcePath = string `/stories/${getEncodedUri(storyGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a story
    #
    # + storyGid - Globally unique identifier for the story
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified story 
    resource isolated function delete stories/[string storyGid](map<string|string[]> headers = {}, *DeleteStoryQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/stories/${getEncodedUri(storyGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get stories from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified task's stories 
    resource isolated function get tasks/[string taskGid]/stories(map<string|string[]> headers = {}, *GetStoriesForTaskQueries queries) returns StoryCompacts|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/stories`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a story on a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The story to create 
    # + return - Successfully created a new story 
    resource isolated function post tasks/[string taskGid]/stories(TaskGidStoriesBody payload, map<string|string[]> headers = {}, *CreateStoryForTaskQueries queries) returns StoryOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/stories`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get multiple tags
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified set of tags 
    resource isolated function get tags(map<string|string[]> headers = {}, *GetTagsQueries queries) returns TagCompacts|error {
        string resourcePath = string `/tags`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a tag
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The tag to create 
    # + return - Successfully created the newly specified tag 
    resource isolated function post tags(TagsBody payload, map<string|string[]> headers = {}, *CreateTagQueries queries) returns TagCreatedResponse|error {
        string resourcePath = string `/tags`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a tag
    #
    # + tagGid - Globally unique identifier for the tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified tag 
    resource isolated function get tags/[string tagGid](map<string|string[]> headers = {}, *GetTagQueries queries) returns TagCreatedResponse|error {
        string resourcePath = string `/tags/${getEncodedUri(tagGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a tag
    #
    # + tagGid - Globally unique identifier for the tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully updated the specified tag 
    resource isolated function put tags/[string tagGid](map<string|string[]> headers = {}, *UpdateTagQueries queries) returns TagCreatedResponse|error {
        string resourcePath = string `/tags/${getEncodedUri(tagGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a tag
    #
    # + tagGid - Globally unique identifier for the tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified tag 
    resource isolated function delete tags/[string tagGid](map<string|string[]> headers = {}, *DeleteTagQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tags/${getEncodedUri(tagGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a task's tags
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the tags for the given task 
    resource isolated function get tasks/[string taskGid]/tags(map<string|string[]> headers = {}, *GetTagsForTaskQueries queries) returns TagCompacts|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/tags`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get tags in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified set of tags 
    resource isolated function get workspaces/[string workspaceGid]/tags(map<string|string[]> headers = {}, *GetTagsForWorkspaceQueries queries) returns TagCompacts|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/tags`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a tag in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The tag to create 
    # + return - Successfully created the newly specified tag 
    resource isolated function post workspaces/[string workspaceGid]/tags(WorkspaceGidTagsBody payload, map<string|string[]> headers = {}, *CreateTagForWorkspaceQueries queries) returns TagCreatedResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/tags`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get multiple task templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved requested task templates 
    resource isolated function get task_templates(map<string|string[]> headers = {}, *GetTaskTemplatesQueries queries) returns TaskTemplateCompacts|error {
        string resourcePath = string `/task_templates`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a task template
    #
    # + taskTemplateGid - Globally unique identifier for the task template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved requested task template 
    resource isolated function get task_templates/[string taskTemplateGid](map<string|string[]> headers = {}, *GetTaskTemplateQueries queries) returns TaskTemplateOkResponse|error {
        string resourcePath = string `/task_templates/${getEncodedUri(taskTemplateGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a task template
    #
    # + taskTemplateGid - Globally unique identifier for the task template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified task template 
    resource isolated function delete task_templates/[string taskTemplateGid](map<string|string[]> headers = {}, *DeleteTaskTemplateQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/task_templates/${getEncodedUri(taskTemplateGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Instantiate a task from a task template
    #
    # + taskTemplateGid - Globally unique identifier for the task template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Describes the inputs used for instantiating a task - the task's name 
    # + return - Successfully created the job to handle task instantiation 
    resource isolated function post task_templates/[string taskTemplateGid]/instantiateTask(TaskTemplateGidInstantiateTaskBody payload, map<string|string[]> headers = {}, *InstantiateTaskQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/task_templates/${getEncodedUri(taskTemplateGid)}/instantiateTask`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get multiple tasks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved requested tasks 
    resource isolated function get tasks(map<string|string[]> headers = {}, *GetTasksQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a task
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The task to create 
    # + return - Successfully created a new task 
    resource isolated function post tasks(TasksBody payload, map<string|string[]> headers = {}, *CreateTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified task 
    resource isolated function get tasks/[string taskGid](map<string|string[]> headers = {}, *GetTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The task to update 
    # + return - Successfully updated the specified task 
    resource isolated function put tasks/[string taskGid](TaskstaskGidBody payload, map<string|string[]> headers = {}, *UpdateTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified task 
    resource isolated function delete tasks/[string taskGid](map<string|string[]> headers = {}, *DeleteTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Duplicate a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Describes the duplicate's name and the fields that will be duplicated 
    # + return - Successfully created the job to handle duplication 
    resource isolated function post tasks/[string taskGid]/duplicate(TaskGidDuplicateBody payload, map<string|string[]> headers = {}, *DuplicateTaskQueries queries) returns JobOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/duplicate`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get tasks from a project
    #
    # + projectGid - Globally unique identifier for the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested project's tasks 
    resource isolated function get projects/[string projectGid]/tasks(map<string|string[]> headers = {}, *GetTasksForProjectQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/projects/${getEncodedUri(projectGid)}/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get tasks from a section
    #
    # + sectionGid - The globally unique identifier for the section
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the section's tasks 
    resource isolated function get sections/[string sectionGid]/tasks(map<string|string[]> headers = {}, *GetTasksForSectionQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/sections/${getEncodedUri(sectionGid)}/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get tasks from a tag
    #
    # + tagGid - Globally unique identifier for the tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the tasks associated with the specified tag 
    resource isolated function get tags/[string tagGid]/tasks(map<string|string[]> headers = {}, *GetTasksForTagQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/tags/${getEncodedUri(tagGid)}/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get tasks from a user task list
    #
    # + userTaskListGid - Globally unique identifier for the user task list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the user task list's tasks 
    resource isolated function get user_task_lists/[string userTaskListGid]/tasks(map<string|string[]> headers = {}, *GetTasksForUserTaskListQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/user_task_lists/${getEncodedUri(userTaskListGid)}/tasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get subtasks from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified task's subtasks 
    resource isolated function get tasks/[string taskGid]/subtasks(map<string|string[]> headers = {}, *GetSubtasksForTaskQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/subtasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a subtask
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new subtask to create 
    # + return - Successfully created the specified subtask 
    resource isolated function post tasks/[string taskGid]/subtasks(TaskGidSubtasksBody payload, map<string|string[]> headers = {}, *CreateSubtaskForTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/subtasks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set the parent of a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new parent of the subtask 
    # + return - Successfully changed the parent of the specified subtask 
    resource isolated function post tasks/[string taskGid]/setParent(TaskGidSetParentBody payload, map<string|string[]> headers = {}, *SetParentForTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/setParent`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get dependencies from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified task's dependencies 
    resource isolated function get tasks/[string taskGid]/dependencies(map<string|string[]> headers = {}, *GetDependenciesForTaskQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/dependencies`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set dependencies for a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of tasks to set as dependencies 
    # + return - Successfully set the specified dependencies on the task 
    resource isolated function post tasks/[string taskGid]/addDependencies(TaskGidAddDependenciesBody payload, map<string|string[]> headers = {}, *AddDependenciesForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/addDependencies`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unlink dependencies from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of tasks to unlink as dependencies 
    # + return - Successfully unlinked the dependencies from the specified task 
    resource isolated function post tasks/[string taskGid]/removeDependencies(TaskGidRemoveDependenciesBody payload, map<string|string[]> headers = {}, *RemoveDependenciesForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/removeDependencies`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get dependents from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the specified dependents of the task 
    resource isolated function get tasks/[string taskGid]/dependents(map<string|string[]> headers = {}, *GetDependentsForTaskQueries queries) returns TaskCompactsResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/dependents`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set dependents for a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of tasks to add as dependents 
    # + return - Successfully set the specified dependents on the given task 
    resource isolated function post tasks/[string taskGid]/addDependents(TaskGidAddDependentsBody payload, map<string|string[]> headers = {}, *AddDependentsForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/addDependents`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unlink dependents from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of tasks to remove as dependents 
    # + return - Successfully unlinked the specified tasks as dependents 
    resource isolated function post tasks/[string taskGid]/removeDependents(TaskGidRemoveDependentsBody payload, map<string|string[]> headers = {}, *RemoveDependentsForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/removeDependents`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add a project to a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project to add the task to 
    # + return - Successfully added the specified project to the task 
    resource isolated function post tasks/[string taskGid]/addProject(TaskGidAddProjectBody payload, map<string|string[]> headers = {}, *AddProjectForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/addProject`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a project from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project to remove the task from 
    # + return - Successfully removed the specified project from the task 
    resource isolated function post tasks/[string taskGid]/removeProject(TaskGidRemoveProjectBody payload, map<string|string[]> headers = {}, *RemoveProjectForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/removeProject`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add a tag to a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The tag to add to the task 
    # + return - Successfully added the specified tag to the task 
    resource isolated function post tasks/[string taskGid]/addTag(TaskGidAddTagBody payload, map<string|string[]> headers = {}, *AddTagForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/addTag`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a tag from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The tag to remove from the task 
    # + return - Successfully removed the specified tag from the task 
    resource isolated function post tasks/[string taskGid]/removeTag(TaskGidRemoveTagBody payload, map<string|string[]> headers = {}, *RemoveTagForTaskQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/removeTag`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add followers to a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The followers to add to the task 
    # + return - Successfully added the specified followers to the task 
    resource isolated function post tasks/[string taskGid]/addFollowers(TaskGidAddFollowersBody payload, map<string|string[]> headers = {}, *AddFollowersForTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/addFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove followers from a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The followers to remove from the task 
    # + return - Successfully removed the specified followers from the task 
    resource isolated function post tasks/[string taskGid]/removeFollowers(TaskGidRemoveFollowersBody payload, map<string|string[]> headers = {}, *RemoveFollowerForTaskQueries queries) returns TaskCreatedResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/removeFollowers`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a task for a given custom ID
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + customId - Generated custom ID for a task
    # + headers - Headers to be sent with the request 
    # + return - Successfully retrieved task for given custom ID 
    resource isolated function get workspaces/[string workspaceGid]/tasks/custom_id/[string customId](map<string|string[]> headers = {}) returns TaskCreatedResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/tasks/custom_id/${getEncodedUri(customId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Search tasks in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the section's tasks 
    resource isolated function get workspaces/[string workspaceGid]/tasks/search(map<string|string[]> headers = {}, *SearchTasksForWorkspaceQueries queries) returns TaskCompacts|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/tasks/search`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a team membership
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team membership 
    resource isolated function get team_memberships/[string teamMembershipGid](map<string|string[]> headers = {}, *GetTeamMembershipQueries queries) returns TeamMembershipOkResponse|error {
        string resourcePath = string `/team_memberships/${getEncodedUri(teamMembershipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get team memberships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team memberships 
    resource isolated function get team_memberships(map<string|string[]> headers = {}, *GetTeamMembershipsQueries queries) returns TeamMembershipCompactsResponse|error {
        string resourcePath = string `/team_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get memberships from a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested team's memberships 
    resource isolated function get teams/[string teamGid]/team_memberships(map<string|string[]> headers = {}, *GetTeamMembershipsForTeamQueries queries) returns TeamMembershipCompactsResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/team_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get memberships from a user
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested users's memberships 
    resource isolated function get users/[string userGid]/team_memberships(map<string|string[]> headers = {}, *GetTeamMembershipsForUserQueries queries) returns TeamMembershipCompactsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}/team_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a team
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The team to create 
    # + return - Successfully created a new team 
    resource isolated function post teams(TeamsBody payload, map<string|string[]> headers = {}, *CreateTeamQueries queries) returns TeamCreatedResponse|error {
        string resourcePath = string `/teams`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a single team 
    resource isolated function get teams/[string teamGid](map<string|string[]> headers = {}, *GetTeamQueries queries) returns TeamCreatedResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The team to update 
    # + return - Successfully updated the team 
    resource isolated function put teams/[string teamGid](TeamsteamGidBody payload, map<string|string[]> headers = {}, *UpdateTeamQueries queries) returns TeamCreatedResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get teams in a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns the team records for all teams in the organization or workspace accessible to the authenticated user 
    resource isolated function get workspaces/[string workspaceGid]/teams(map<string|string[]> headers = {}, *GetTeamsForWorkspaceQueries queries) returns TeamCompactsResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/teams`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get teams for a user
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns the team records for all teams in the organization or workspace to which the given user is assigned 
    resource isolated function get users/[string userGid]/teams(map<string|string[]> headers = {}, *GetTeamsForUserQueries queries) returns TeamCompactsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}/teams`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add a user to a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to add to the team 
    # + return - Successfully added user to the team 
    resource isolated function post teams/[string teamGid]/addUser(TeamGidAddUserBody payload, map<string|string[]> headers = {}, *AddUserForTeamQueries queries) returns TeamMembershipOkResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/addUser`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a user from a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to remove from the team 
    # + return - Returns an empty data record 
    resource isolated function post teams/[string teamGid]/removeUser(TeamGidRemoveUserBody payload, map<string|string[]> headers = {}, *RemoveUserForTeamQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/removeUser`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a time period
    #
    # + timePeriodGid - Globally unique identifier for the time period
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the record for a single time period 
    resource isolated function get time_periods/[string timePeriodGid](map<string|string[]> headers = {}, *GetTimePeriodQueries queries) returns TimePeriodOkResponse|error {
        string resourcePath = string `/time_periods/${getEncodedUri(timePeriodGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get time periods
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested time periods 
    resource isolated function get time_periods(map<string|string[]> headers = {}, *GetTimePeriodsQueries queries) returns TimePeriodCompactsResponse|error {
        string resourcePath = string `/time_periods`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get time tracking entries for a task
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested time tracking entries 
    resource isolated function get tasks/[string taskGid]/time_tracking_entries(map<string|string[]> headers = {}, *GetTimeTrackingEntriesForTaskQueries queries) returns TimeTrackingEntryCompactsResponse|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/time_tracking_entries`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a time tracking entry
    #
    # + taskGid - The task to operate on
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information about the time tracking entry 
    # + return - Successfully created a time tracking entry for the task 
    resource isolated function post tasks/[string taskGid]/time_tracking_entries(TaskGidTimeTrackingEntriesBody payload, map<string|string[]> headers = {}, *CreateTimeTrackingEntryQueries queries) returns TimeTrackingEntryBases|error {
        string resourcePath = string `/tasks/${getEncodedUri(taskGid)}/time_tracking_entries`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a time tracking entry
    #
    # + timeTrackingEntryGid - Globally unique identifier for the time tracking entry
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested time tracking entry 
    resource isolated function get time_tracking_entries/[string timeTrackingEntryGid](map<string|string[]> headers = {}, *GetTimeTrackingEntryQueries queries) returns TimeTrackingEntryBases|error {
        string resourcePath = string `/time_tracking_entries/${getEncodedUri(timeTrackingEntryGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a time tracking entry
    #
    # + timeTrackingEntryGid - Globally unique identifier for the time tracking entry
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated fields for the time tracking entry 
    # + return - Successfully updated the time tracking entry 
    resource isolated function put time_tracking_entries/[string timeTrackingEntryGid](TimeTrackingEntriestimeTrackingEntryGidBody payload, map<string|string[]> headers = {}, *UpdateTimeTrackingEntryQueries queries) returns TimeTrackingEntryBases|error {
        string resourcePath = string `/time_tracking_entries/${getEncodedUri(timeTrackingEntryGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a time tracking entry
    #
    # + timeTrackingEntryGid - Globally unique identifier for the time tracking entry
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully deleted the specified time tracking entry 
    resource isolated function delete time_tracking_entries/[string timeTrackingEntryGid](map<string|string[]> headers = {}, *DeleteTimeTrackingEntryQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/time_tracking_entries/${getEncodedUri(timeTrackingEntryGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get objects via typeahead
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved objects via a typeahead search algorithm 
    resource isolated function get workspaces/[string workspaceGid]/typeahead(map<string|string[]> headers = {}, *TypeaheadForWorkspaceQueries queries) returns AsanaNamedResources|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/typeahead`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a user task list
    #
    # + userTaskListGid - Globally unique identifier for the user task list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the user task list 
    resource isolated function get user_task_lists/[string userTaskListGid](map<string|string[]> headers = {}, *GetUserTaskListQueries queries) returns UserTaskListOkResponse|error {
        string resourcePath = string `/user_task_lists/${getEncodedUri(userTaskListGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a user's task list
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the user's task list 
    resource isolated function get users/[string userGid]/user_task_list(map<string|string[]> headers = {}, *GetUserTaskListForUserQueries queries) returns UserTaskListOkResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}/user_task_list`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested user records 
    resource isolated function get users(map<string|string[]> headers = {}, *GetUsersQueries queries) returns UserCompactsResponse|error {
        string resourcePath = string `/users`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a user
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns the user specified 
    resource isolated function get users/[string userGid](map<string|string[]> headers = {}, *GetUserQueries queries) returns UserOkResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a user's favorites
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns the specified user's favorites 
    resource isolated function get users/[string userGid]/favorites(map<string|string[]> headers = {}, *GetFavoritesForUserQueries queries) returns AsanaNamedResourceResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}/favorites`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get users in a team
    #
    # + teamGid - Globally unique identifier for the team
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns the user records for all the members of the team, including guests and limited access users 
    resource isolated function get teams/[string teamGid]/users(map<string|string[]> headers = {}, *GetUsersForTeamQueries queries) returns UserCompacts|error {
        string resourcePath = string `/teams/${getEncodedUri(teamGid)}/users`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get users in a workspace or organization
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Return the users in the specified workspace or org 
    resource isolated function get workspaces/[string workspaceGid]/users(map<string|string[]> headers = {}, *GetUsersForWorkspaceQueries queries) returns UserCompacts|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/users`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple webhooks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested webhooks 
    resource isolated function get webhooks(map<string|string[]> headers = {}, *GetWebhooksQueries queries) returns WebhookOkResponse|error {
        string resourcePath = string `/webhooks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Establish a webhook
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The webhook workspace and target 
    # + return - Successfully created the requested webhook 
    resource isolated function post webhooks(WebhooksBody payload, map<string|string[]> headers = {}, *CreateWebhookQueries queries) returns EnumOptions0|error {
        string resourcePath = string `/webhooks`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a webhook
    #
    # + webhookGid - Globally unique identifier for the webhook
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested webhook 
    resource isolated function get webhooks/[string webhookGid](map<string|string[]> headers = {}, *GetWebhookQueries queries) returns EnumOptions0|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a webhook
    #
    # + webhookGid - Globally unique identifier for the webhook
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated filters for the webhook 
    # + return - Successfully updated the webhook 
    resource isolated function put webhooks/[string webhookGid](WebhookswebhookGidBody payload, map<string|string[]> headers = {}, *UpdateWebhookQueries queries) returns EnumOptions0|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a webhook
    #
    # + webhookGid - Globally unique identifier for the webhook
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested webhook 
    resource isolated function delete webhooks/[string webhookGid](map<string|string[]> headers = {}, *DeleteWebhookQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookGid)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a workspace membership
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested workspace membership 
    resource isolated function get workspace_memberships/[string workspaceMembershipGid](map<string|string[]> headers = {}, *GetWorkspaceMembershipQueries queries) returns WorkspaceMembershipOkResponse|error {
        string resourcePath = string `/workspace_memberships/${getEncodedUri(workspaceMembershipGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workspace memberships for a user
    #
    # + userGid - A string identifying a user. This can either be the string "me", an email, or the gid of a user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested user's workspace memberships 
    resource isolated function get users/[string userGid]/workspace_memberships(map<string|string[]> headers = {}, *GetWorkspaceMembershipsForUserQueries queries) returns WorkspaceMembershipCompactResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userGid)}/workspace_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get the workspace memberships for a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully retrieved the requested workspace's memberships 
    resource isolated function get workspaces/[string workspaceGid]/workspace_memberships(map<string|string[]> headers = {}, *GetWorkspaceMembershipsForWorkspaceQueries queries) returns WorkspaceMembershipCompactResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/workspace_memberships`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get multiple workspaces
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Return all workspaces visible to the authorized user 
    resource isolated function get workspaces(map<string|string[]> headers = {}, *GetWorkspacesQueries queries) returns WorkspaceCompactResponse|error {
        string resourcePath = string `/workspaces`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Return the full workspace record 
    resource isolated function get workspaces/[string workspaceGid](map<string|string[]> headers = {}, *GetWorkspaceQueries queries) returns WorkspaceOkResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a workspace
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The workspace object with all updated properties 
    # + return - Update for the workspace was successful 
    resource isolated function put workspaces/[string workspaceGid](WorkspacesworkspaceGidBody payload, map<string|string[]> headers = {}, *UpdateWorkspaceQueries queries) returns WorkspaceOkResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Add a user to a workspace or organization
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to add to the workspace 
    # + return - The user was added successfully to the workspace or organization 
    resource isolated function post workspaces/[string workspaceGid]/addUser(WorkspaceGidAddUserBody payload, map<string|string[]> headers = {}, *AddUserForWorkspaceQueries queries) returns UserBaseOkResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/addUser`;
        map<Encoding> queryParamEncoding = {"opt_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a user from a workspace or organization
    #
    # + workspaceGid - Globally unique identifier for the workspace or organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to remove from the workspace 
    # + return - The user was removed successfully to the workspace or organization 
    resource isolated function post workspaces/[string workspaceGid]/removeUser(WorkspaceGidRemoveUserBody payload, map<string|string[]> headers = {}, *RemoveUserForWorkspaceQueries queries) returns EmptyOkResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceGid)}/removeUser`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
